<div id="ajax-page" class="ajax-page-content">
    <div class="ajax-page-wrapper">
        <div class="ajax-page-nav">
            <div class="nav-item ajax-page-prev-next">
                <a class="ajax-page-load" href="./these/t_chap6.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                <a class="ajax-page-load" href="./these/t_chap8.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
            </div>
            <div class="nav-item ajax-page-close-button">
                <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
            </div>
        </div>

        <div class="ajax-page-title">
            <div class="chapter-title"><h2>Conclusion</h2></div>
        </div>

        <div class="row">
            <br/>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap1.html"> Chapitre 1 : Simulation multi-agent</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap2.html"> Chapitre 2 : Calcul haute performance et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap3.html"> Chapitre 3 : Simulations multi-agents et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap4.html"> Chapitre 4 : Le principe de délégation GPU des perceptions agents</a></p></li>
                </ul>
            </div>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap5.html"> Chapitre 5 : Expérimentation du principe de délégation GPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap6.html"> Chapitre 6 : Définition d'une méthode de conception basée sur la délégation GPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap8.html"> Chapitre 8 : Perspectives de recherche</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_bib.html"> Bibliographie</a></p></li>
                </ul>                
            </div>
            
            <p>La grande diversité des objectifs que la simulation multi-agents peut adresser (étude de systèmes complexes, de phénomènes biologiques, conception de systèmes multi-agents pour la robotique, etc.) montre toute la richesse du paradigme multi-agent. L'augmentation des capacités de calcul de nos ordinateurs actuels ainsi que la qualité (et la variété) des outils existants, dédiés à ce paradigme de conception, ont permis une envolée spectaculaire du nombre de simulations multi-agents et témoigne de sa popularité grandissante.</p>

            <p>Cependant, les performances constituent un verrou majeur dans ce domaine. Ainsi, il n'est pas rare de devoir simplifier le modèle ou de faire des compromis sur les caractéristiques de ce dernier pour compenser les limites introduites par ce manque de performance. D'autant plus, à l'heure où il est de plus en plus question de simulations à large échelle et/ou multi-niveaux, on peut facilement prédire que le besoin en ressources de calcul va augmenter de manière quasi exponentielle à court et moyen termes.</p>

            <p>Ainsi, la motivation de notre travail de thèse a été d'apporter des solutions aux problèmes de performance que l'on peut rencontrer quand on simule des modèles multi-agents. Suivant les orientations prises en direction du calcul haute performance par différents groupes de recherche et industriels, nous nous sommes tournés en particulier vers l'utilisation de la puissance computationelle des cartes graphiques via le GPGPU. Cette technologie offre en effet un des meilleurs rapport en termes de performance, prix et consommation énergétique tout en permettant à tout un chacun d'utiliser une solution de calcul intensif grâce à la disponibilité de cette dernière dans de nombreux ordinateurs.</p>

            <p>Néanmoins, malgré les avantages que peut avoir le GPGPU, nous avons souligné que cette technologie est difficile à mettre en oeuvre. Le GPGPU s'accompagne en effet d'un contexte de programmation particulier du fait qu'il s'appuie sur un parallélisme de type SIMD qui nécessite notamment de suivre les principes de la programmation par traitement de flux de données (<i>stream processing paradigm</i>). Utiliser le GPGPU de manière efficiente peut donc être très complexe selon le cadre et les objectifs poursuivis.</p>

            <br/>
            <div class="block-title">
                <h3>Problématiques abordées</h3>
            </div>

            <p>Dans le cadre des simulations multi-agents, les spécificités d'implémentation qui accompagnent la programmation sur GPU obligent à repenser la modélisation multi-agents, notamment car il n'est pas possible d'adopter une conception orientée objet classique. De ce fait, les modèles multi-agents usuels ne peuvent être simulés sur GPU sans un effort de traduction conséquent et non trivial.</p>

            <p>De plus, considérer l'utilisation des GPU, reposant sur des architectures massivement parallèles, pour accélérer l'exécution des simulations exacerbe les problèmes d'implémentation déjà présents en séquentiel. En effet, les différents outils dédiés à la simulation multi-agent proposent une programmation haut niveau limitant la réutilisabilité des modèles sur d'autres plates-formes. Cela oblige également d'adopter une philosophie et une modélisation propre à chacun des outils ce qui restreint fortement l'accessibilité de ces derniers.</p>

            <p>Dans ce contexte, nous avons réalisé un état de l'art des travaux mêlant GPGPU et simulations multi-agents afin d'examiner les directions de recherche prises par la communauté. Cet état de l’art [Hermellin-JFSMA-2014, Hermellin-RIA-2015] nous a permis d'identifier deux approches d'implémentation différentes.</p>
            <ul>
                <li><p>La première consiste à implémenter la simulation entièrement sur le GPU (tout-sur-GPU). Cependant, de par la difficulté de proposer des solutions de modélisation multi-agent réutilisables et accessibles intégrant le GPGPU, la plupart des travaux basés sur cette approche reste focalisée sur une recherche de performances brutes dans un contexte applicatif. Il existe bien certains travaux qui tentent tout de même de pallier les contraintes du GPGPU en encapsulant son usage dans un langage de plus haut niveau, mais ces solutions restent compliquées du point de vue de l'accessibilité.</p></li>
                <li><p>La deuxième est dite hybride et consiste à partager l'exécution d'une simulation entre le CPU et le GPU. Ainsi, au contraire du tout-sur-GPU, cette approche se veut plus modulaire de par le fait qu'il est possible de choisir ce qui va être exécuté ou non sur le GPU. Cela permet d'envisager des simulations multi-agents plus complexes avec, par exemple, des modèles d'agents qui mélangent architectures réactives et cognitives. Grâce à sa conception, l'approche hybride offre également la possibilité de prendre en considération des aspects tels que l'accessibilité, la réutilisabilité et la généricité des solutions proposées.</p></li>
            </ul>

            <p>Grâce à cet état de l'art, nous avons également remarqué que la majorité des travaux basés sur une approche hybride cache l'utilisation du GPGPU aux utilisateurs : le recours au GPGPU se fait alors de manière totalement transparente. Ce choix, à cause de la très grande variété des modèles, n'est cependant pas assez générique et ne permet pas de prendre en compte tous les cas et besoins que l'implémentation d'un modèle multi-agent exécuté sur le GPGPU peut nécessiter.</p>

            <p>Ainsi, et comme conclusion à cette étude, nous avons argumenté qu'une meilleure intégration du GPGPU ne pouvait se faire qu'avec une amélioration de l'accessibilité, de la réutilisabilité et de la généricité des solutions proposées et qu'elle passait nécessairement par l'utilisation d'une approche hybride. La difficulté était donc de trouver une solution répondant à ces critères.</p>

            <br/>
            <div class="block-title">
                <h3>Résumé des contributions</h3>
            </div>

            <p>Nous avons présenté le principe de <i>délégation GPU des perceptions agents</i>. Celui-ci propose d'utiliser de manière directe le GPGPU (et donc de profiter de la puissance des GPU) au travers d'une approche hybride tout en conservant l'accessibilité et la facilité de réutilisation d'une interface de programmation orientée objet. Proche des objectifs poursuivis dans cette thèse et des critères que nous avons identifiés comme nécessaires à une meilleure intégration du GPGPU, nous avons ainsi choisi ce principe comme base de départ à nos recherches et développements.</p>

            <p>Ce principe de conception, qui appartient au courant E4MAS [E4MAS2015], s'inspire de travaux tels que [Weyns2007, Ricci2011]. Ainsi, de la même manière que pour les <i>artefacts</i> [Ricci2011], ce principe propose de réifier une partie des calculs du modèle (comme les calculs de perception) dans l'environnement sous la forme de dynamiques environnementales traitées par des modules de calcul GPU. Cependant, ce principe n'ayant été appliqué que sur un cas d'étude prometteur [Michel2013], il était difficile de présager de ses capacités réelles.</p>

            <p>Nous avons donc décidé de mettre à l'épreuve la faisabilité et la réutilisabilité de ce principe en l'appliquant dans un premier temps sur le modèle des <i>boids</i> de Reynolds [Hermellin-JFSMA-2015, Hermellin-MABS-2015, Hermellin-RIA-2016]. Grâce à cette première expérimentation, nous avons pu nous approprier ce principe de conception et surtout le faire évoluer. En effet, nous avons étendu le critère du principe de délégation GPU afin de le rendre plus générique.</p>

            <p>Pour tester sa généricité, nous avons appliqué cette nouvelle version du principe de délégation GPU sur quatre autres modèles multi-agents : <i>Game of life</i>, <i>Schelling's Segregation</i>, <i>Fire</i> et <i>DLA</i> [Hermellin-AAMAS-2016]. Cette expérimentation a souligné la capacité de l'approche à produire des modules GPU indépendants et réutilisables. De plus, grâce à la modularité apportée par l'approche hybride utilisée, les modules GPU créés reposent sur des <i>kernels</i> très simples (seulement quelques lignes de code) améliorant de ce fait l'accessibilité du GPGPU.</p>

            <p>D'ailleurs, il est apparu durant ces applications successives du principe de délégation GPU que nous suivions toujours le même processus d'implémentation [Hermellin-CNSC-2016]. Ainsi, nous avons généralisé l'application du principe de délégation GPU sous la forme d'une méthode de conception basée sur ce principe. Ici, notre objectif a été de permettre à un développeur n'ayant aucune expérience dans le domaine de la programmation GPU de l'aborder d'une manière simple, et surtout itérative.</p>

            <table>
                <tbody>
                    <tr>
                        <td><b>Modèle</b></td>
                        <td colspan="4"><b>Gain de performance</b></td>
                        <td><b>Densité d'agents</b></td>
                        <td><b>Calcul traduit</b></td>
                        <td><b>Module GPU</b></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td colspan="4">Taille de l'environnement</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>256</td>
                        <td>512</td>
                        <td>1024</td>
                        <td>2048</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Flocking</td>
                        <td>1.4</td>
                        <td>1.4</td>
                        <td></td>
                        <td></td>
                        <td>entre 1 % et 61 %</td>
                        <td>calcul des orientations</td>
                        <td><i>Average</i></td>
                    </tr> 
                    <tr>
                        <td>Game of Life</td>
                        <td>2.00</td>
                        <td>2.20</td>
                        <td>2.23</td>
                        <td>5.10</td>
                        <td>fixée à 50 %</td>
                        <td>mise à jour des états</td>
                        <td><i>Voisinage</i></td>
                    </tr>
                    <tr>
                        <td>Segregation</td>
                        <td>4.80</td>
                        <td>4.70</td>
                        <td>4.65</td>
                        <td>4.60</td>
                        <td>fixée à 90 %</td>
                        <td>détéction des voisins</td>
                        <td><i>Voisinage</i></td>
                    </tr>
                    <tr>
                        <td>Fire</td>
                        <td>1.40</td>
                        <td>1.64</td>
                        <td>1.79</td>
                        <td>2.09</td>
                        <td>entre 10 % et 100 %</td>
                        <td>diffusion de la chaleur</td>
                        <td><i>Diffusion</i></td>
                    </tr>
                    <tr>
                        <td>DLA</td>
                        <td>13.5</td>
                        <td>12.7</td>
                        <td>10.7</td>
                        <td>10.0</td>
                        <td>entre 10 % et 90 %</td>
                        <td>détéction de présence</td>
                        <td><i>Voisinage</i></td>
                    </tr>
                    <tr>
                        <td>Heatbugs</td>
                        <td>1.04</td>
                        <td>1.06</td>
                        <td>1.08</td>
                        <td>1.10</td>
                        <td>fixée à 40 %</td>
                        <td>diffusion de la chaleur et delta température</td>
                        <td><i>Différence</i></td>
                    </tr>
                    <tr>
                        <td>Proie-prédateur</td>
                        <td>2.0</td>
                        <td>2.1</td>
                        <td>2.5</td>
                        <td>4.5</td>
                        <td>fixée à 20 % et 40 %</td>
                        <td>gradient de présence</td>
                        <td><i>GPU field</i></td>
                    </tr> 
                </tbody>
            </table>
            
            <p>Nous avons donc défini une méthode générique de conception qui se focalise sur l'accessibilité et permet de capitaliser sur les efforts de modélisation et d'implémentation. Au vu des résultats obtenus suite aux différentes expérimentations réalisées, la définition de cette méthode nous a permis d'atteindre les objectifs définis au début de ce manuscrit en proposant une solution qui :</p>
            <ul>
                <li><p>améliore l'<b>accessibilité</b> du GPGPU dans le contexte des simulations multi-agents ;</p></li>
                <li><p>définit une approche <b>générique</b> permettant de considérer des modèles multi-agents plus hétérogènes ;</p></li>
                <li><p>promeut une <b>réutilisabilité</b> des outils créés et du code développé.</p></li>
            </ul>

            <p>Ainsi, alors que nous avons montré que le GPGPU peinait à être adopté dans le domaine des simulations multi-agents, le cadre conceptuel qu'offre la méthode développée dans ce manuscrit devrait permettre une meilleure intégration de cette technologie dans ce domaine. En cela, elle devrait également accroître la diffusion de cette technologie dans la communauté multi-agent.</p>

            <p>De plus, alors qu'au départ le principe de délégation GPU permettait de transformer en dynamiques environnementales uniquement des calculs de perception n'impliquant pas les états des agents, la définition de la méthode nous montre que maintenant tous les calculs présents dans le modèle multi-agent peuvent être pris en compte. En effet, lors de la première étape de cette méthode, nous considérons tous les calculs du modèle afin de vérifier leur compatibilité avec les critères du principe de délégation. Ainsi, cette méthode propose d'identifier et de déléguer à l'environnement des calculs de pré-traitements et cela sans distinction de contexte (perception, délibération, etc.). Cela ouvre des perspectives intéressantes d'un point de vue génie logiciel orienté agent surtout dans le contexte E4MAS dans lequel on se trouve (complexité du modèle agent, conception et modelisation des modèles agents, etc.).</p>

            <p>En ce qui concerne les limites de notre approche, on voit en particulier que les résultats de performance obtenus sont très différents en fonction des modèles considérés. De très bons pour le modèle <i>DLA</i>) à peu significatifs (pour le modèle <i>Heatbugs</i>), ces résultats variables soulignent la difficulté actuelle de notre méthode à prédire le niveau de gain qu'il va être possible d'obtenir. De ce fait, il va donc être nécessaire de travailler sur une meilleure intégration de cette méthode dans les outils qui lui sont associés et de proposer des solutions claires autour de ces variations de performance. Cela représente une partie des perspectives de recherche autour de ce travail et nous allons les détailler dans le prochain chapitre.</p>

            <br/>

            <div id="chart_ccl" class="chart"></div>

            <div class="ajax-page-nav">
                <div class="nav-item ajax-page-prev-next">
                    <a class="ajax-page-load" href="./these/t_chap6.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                    <a class="ajax-page-load" href="./these/t_chap8.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
                </div>
                <div class="nav-item ajax-page-close-button">
                    <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
                </div>
            </div>

            <script type="text/javascript">
                function customAjaxScroll() {
                        var windowWidth = $(window).width();
                        if (windowWidth > 991) {
                            // Custom Ajax Page Scroll
                            $("#ajax-page").mCustomScrollbar({
                                scrollInertia: 8,
                                documentTouchScroll: false
                            });
                        } else {
                            $("#ajax-page").mCustomScrollbar('destroy');
                        }
                    }

                    jQuery(document).ready(function($){

                        // Ajax Loaded Page Scroll
                        customAjaxScroll();

                        Highcharts.chart('chart_ccl', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Gains de performance obtenus lors des différentes expérimentations'
                            },
                            xAxis: {
                                title: {
                                    text: 'Taille environnement'
                                },
                                categories: ['256', '512', '1024', '2048']
                            },
                            yAxis: {
                                title: {
                                    text: 'Gains de performance'
                                }
                            },
                            series: [{
                                name: 'MLE',
                                data: [3.42, 4.37, 6.96]
                            },{
                                name: 'Flocking',
                                data: [1.40, 1.40]
                            },{
                                name: 'Game of Life',
                                data: [2.0, 2.2, 2.23, 5.10]
                            },{
                                name: 'Segregation',
                                data: [4.8, 4.7, 4.65, 4.6]
                            },{
                                name: 'Fire',
                                data: [1.4, 1.64, 1.79, 2.09]
                            },{
                                name: 'DLA',
                                data: [13.5, 12.7, 10.7, 10.0]
                            },{
                                name: 'Heatbugs',
                                data: [1.04, 1.06, 1.08, 1.10]
                            },{
                                name: 'Proie-prédateur',
                                data: [2, 2.1, 2.5, 4.5]
                            }]
                        });


                        $('.portfolio-page-carousel').owlCarousel({
                            smartSpeed:1200,
                            items: 1,
                            loop: true,
                            dots: true,
                            nav: true,
                            navText: false,
                            margin: 10
                        });

                    });

                    jQuery(window).on('resize', function() {
                        customAjaxScroll();
                    });

            </script>
        </div>
    </div>
</div>

<div id="ajax-page" class="ajax-page-content">
    <div class="ajax-page-wrapper">
        <div class="ajax-page-nav">
            <div class="nav-item ajax-page-prev-next">
                <a class="ajax-page-load" href="./these/t_chap7.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                <a class="ajax-page-load" href="./these/t_annexes.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
            </div>
            <div class="nav-item ajax-page-close-button">
                <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
            </div>
        </div>

        <div class="ajax-page-title">
            <div class="chapter-title"><h2>Perspectives de recherche</h2></div>
        </div>

        <div class="row">
            <br/>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap1.html"> Chapitre 1 : Simulation multi-agent</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap2.html"> Chapitre 2 : Calcul haute performance et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap3.html"> Chapitre 3 : Simulations multi-agents et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap4.html"> Chapitre 4 : Le principe de délégation GPU des perceptions agents</a></p></li>
                </ul>
            </div>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap5.html"> Chapitre 5 : Expérimentation du principe de délégation GPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap6.html"> Chapitre 6 : Définition d'une méthode de conception basée sur la délégation GPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap7.html"> Chapitre 7 : Conclusion</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_bib.html"> Bibliographie</a></p></li>
                </ul>                
            </div>

            <p>Si la méthode de conception que nous avons proposé est fonctionnelle et offre un cadre opérationnel permettant d'utiliser le GPGPU dans les simulations multi-agents, elle représente une solution appelée à évoluer, d'une part pour combler ses limites, d'autre part pour répondre à un domaine très dynamique. Ainsi, nous présentons maintenant quelques-unes des perspectives de recherche que nous considérons comme importantes à explorer. Celles-ci peuvent être divisées en deux parties :</p>
            <ul>
                <li><p>À court terme, il s'agit d'abord de travailler sur les outils logiciels associés à notre méthode et sur son intégration en leur sein. Ceci afin de rendre ces outils encore plus accessibles et génériques mais aussi pour étendre le champ d'application de notre méthode tout en répondant aux différentes limites soulevées tout au long de ce manuscrit.</p></li>
                <li><p>À moyen et long termes, il nous semble important de réfléchir au positionnement de notre méthode dans le domaine des simulations multi-agents et, d'une manière plus générale, à l'apport que peut avoir une telle méthode dans le cadre du génie logiciel orienté agent.</p></li>
            </ul>

            <br/>
            <div class="block-title">
                <h3>Perspectives à court terme</h3>
            </div>

            <h4>Améliorer les outils et l'intégration de la méthode dans ces derniers</h4>
            
            <p>Pour tous nos tests d'intégration du GPGPU dans des simulations multi-agents, nous avons utilisé la plate-forme TurtleKit. Cependant, l'architecture de cette dernière n'a jamais été pensée dans l'optique d'intégrer cette technologie et encore moins des modules de calcul GPU. Ainsi, maintenant que nous avons défini une méthode fonctionnelle autour du GPGPU et malgré le fait que TutleKit permet d'intégrer les modules créés avec cette méthode, il convient maintenant de repenser son architecture.</p>

            <p>Dans un premier temps, l'architecture de TurleKit se doit d'être plus modulaire ceci afin de simplifier le développement et l'intégration des modules GPU. Ensuite, cette architecture devra également permettre la réutilisation directe des modules entre les simulations et cela sans avoir à modifier au préalable le noyau de la plate-forme (ce qui est le cas actuellement). Enfin, nous pouvons imaginer la création d'une solution logicielle accompagnant l'utilisateur dans l'application des différentes étapes de la méthode. Celle-ci pourrait prendre par exemple la forme d'un assistant de configuration tel qu'on en trouve dans bon nombre de logiciels.</p>

            <p>D'une manière générale, cette piste de recherche à court terme consiste globalement à proposer une meilleure intégration de notre méthode dans la plate-forme TurtleKit afin d'améliorer toujours plus son accessibilité et favoriser la réutilisation des modules.</p>

            <h4>Variation des performances et estimation des gains</h4>

            <p>Nous avons observé que les gains de performance (obtenus grâce à notre méthode) variaient énormément en fonction du modèle considéré. En effet, même si un modèle valide la deuxième étape de notre méthode (compatibilité des calculs), les gains de performance peuvent ne pas être intéressants car ces derniers dépendent fortement de la configuration matérielle utilisée ainsi que des caractéristiques du modèle considéré.
            Cette disparité des résultats représente clairement une limite de notre méthode car il devient alors difficile d'estimer avec précision les gains escomptés. Mais surtout il est très complexe, dans ce contexte, d'identifier si un modèle pourra bénéficier ou non du GPGPU.</p> 

            <p>Pour remédier à ce problème, une des solutions que nous envisageons repose sur la création d'un outil de benchmark qui permettrait de définir l'intérêt d'appliquer notre méthode sur le modèle considéré en fonction du nombre d'agents et de la configuration matérielle utilisée. Autrement dit, l'idée est de proposer un outil qui implémente plusieurs modèles jouets (des exemples de simulations multi-agents très représentatives des dynamiques que l'on peut rencontrer, <i>toys models</i>) comportant un ensemble de fonctions agents et de dynamiques environnementales récurrentes, ces dernières réutilisant les modules GPU créés avec notre méthode. Ainsi, l'utilisateur qui exécutera ces simulations pourra avoir une idée du seuil au-dessus duquel une implémentation GPU pourrait être efficiente et se faire un avis sur les gains de performances qu'il sera possible d'obtenir en fonction des caractéristiques de son propre modèle et de la configuration utilisée.</p>

            <h4>Elargir le champ d'application de la méthode</h4>
            <p>Nous avons souligné la polyvalence de notre méthode dans le sens où elle peut être appliquée sur une grande variété de modèles. Cependant, il nous faut modérer cet avantage car tous nos cas d'études ont porté sur des modèles possédant des caractéristiques communes (comme un environnement discrétisé par exemple). En effet, un des cadres de notre méthode a été d'appliquer des dynamiques environnementales sur un environnement discrétisé pour lequel le principe de délégation GPU est facilement implémentable.</p>

            <p>Cependant, notre méthode n'est pas limitée à ce contexte. Il n'est jamais fait mention dans ses critères ou au cours des différentes étapes d'une obligation pour les modèles de posséder un environnement discrétisé. Ainsi, un de nos objectifs sera de considérer d'autres types de modèle sur lesquels appliquer notre méthode de conception comme par exemple des modèles possédant des environnements continus.</p>

            <p>La question qui se posera alors, est de savoir s'il faudra faire évoluer notre méthode pour prendre en compte concrètement les environnements continus ou s'il faudra proposer une conversion des modèles continus vers une version discrète. Cette question est légitime car l'application de cette méthode est rendue plus facile par la discrétisation de l'environnement. Cette dernière simplifie en effet la parallélisation (adéquation entre l'environnement et l'architecture du GPU) mais aussi l'application des dynamiques environnementales. Un bon exemple est celui de notre modèle de <i>flocking</i> qui est de base un modèle continu mais qui, de par son implémentation dans TurtleKit (qui plonge les modèles dans un environnement discret), a permis une application rapide du principe de délégation GPU.</p>

            <p>Ouvrir notre méthode à de nouveaux types de modèle devrait, dans tous les cas, renforcer son champ d'application et permettre de définir de nouveaux modules GPU réutilisables.</p>

            <br/>
            <div class="block-title">
                <h3>Perspectives à moyen et long termes</h3>
            </div>

            <h4>Impact sur le génie logiciel orienté agent</h4>

            <p>Nous avons à plusieurs reprises souligné la complexité liée à la conception de simulations multi-agents et à l'utilisation des plates-formes dédiées. Nous avons montré que la grande diversité des plates-formes de développement et leurs spécificités n'offraient pas des conditions optimales de développement dans le sens où leur accessibilité ainsi que la réutilisabilité des modèles créés avec ces outils pouvaient être limitées. Nous avons établi que les architectures parallèles allaient exacerber les problèmes déjà présents en séquentiel. Ainsi, et d'une manière générale, on a besoin de solutions qui facilitent la modélisation et l'implémentation de simulations multi-agents et cela quelque soit le contexte technologique.</p>

            <p>Le courant E4MAS, que nous avons évoqué plusieurs fois dans ce manuscrit, s'inscrit dans cette perspective de simplification au travers d'une décomplexification des comportements agents rendus possible grâce à la place donnée aux environnements (l'environnement est considéré comme essentiel). Bien que l'on ait mis de côté cet aspect, la question de la complexité prend tout son sens avec la méthode que nous proposons car le fait de se baser sur le principe de délégation GPU (qui explicite la séparation entre le modèle agent et l'environnement) et le fait de choisir ce qui va être exécuté par le GPU (grâce à l'approche hybride), permet de fournir à l'agent des percepts et des moyens d'action de haut niveau, afin de simplifier son comportement et d'en garder l'essentiel. En ce sens, nos contributions poursuivent bien les perspectives du courant E4MAS et s'inscrivent dans la lignée de travaux tels que [Viroli2006, Weyns2007, Ricci2011, Michel2015, E4MAS2015].</p>

            <p>Ainsi, toujours dans une démarche de génie logiciel orienté agent, il semblerait pertinent d'étudier l'impact que peut avoir notre méthode sur la programmation multi-agents. Plus précisément, il conviendrait d'évaluer la capacité de notre méthode à simplifier l'implémentation et la modélisation multi-agent et cela en dehors d'un contexte GPGPU. Un exemple qui nous conforte dans l'intérêt de cette perspective de recherche est celui de l'expérimentation du modèle Proie-prédateur. L'application de notre méthode sur ce modèle a mené à la disparition de tous les calculs annexes aux comportements des agents permettant de ce fait d'avoir un modèle comportemental (et donc son code source) très lisible et facilement compréhensible.</p>

            <h4>Ordonnancement et dynamiques</h4> 

            <p>Un autre aspect n'a pas pu être abordé dans cette thèse : celui de l'apparition de nouvelles dynamiques suite aux modifications engendrées par l'application de notre méthode sur les modèles considérés. Pourtant, nos simulations de <i>flocking</i> ont montré que, selon la version du modèle exécutée (séquentielle ou hybride), les comportements collectifs observés pouvaient être très différents.</p> 

            <p>En effet, dans la version séquentielle, l'ordonnancement du modèle (les agents perçoivent et agissent directement les uns après les autres) va faire converger l'orientation moyenne des agents du système vers une valeur commune modulo une petite variation aléatoire sur les directions individuelles. Visuellement parlant, il en résulte un <i>flocking</i> statique (mouvement coordonné dans une unique direction modulo de petites variations) similaire à ce que l'on peut observer dans les plates-formes multi-agents. Dans la version hybride utilisant le module GPU <i>Average</i>, tous les agents perçoivent le même état de l'environnement pour un même instant t. Ainsi, le système ne converge pas vers une valeur unique, comme c'est le cas pour la version séquentielle. Il en résulte des comportements collectifs de <i>flocking</i> plus riches en terme de dynamique, avec des changements de directions collectifs soudains et importants.</p>

            <p>L'application de notre méthode peut donc ne pas être neutre mais elle souligne également l'importance que l'on doit donner à l'ordonnancement (l’ordre dans lequel les agents sont activés et produisent leurs perceptions et actions). Il existe d'ailleurs de nombreux de travaux qui traitent de l'ordonnancement dans les systèmes multi-agents et de l'impact qu'il peut avoir sur l'exécution et la dynamique des systèmes. Parmi ces travaux, on peut citer par exemple [Chevrier2010] qui montre que même avec seulement deux agents aux comportements minimalistes, plongés dans un environnement simple, il est possible d’obtenir des dynamiques très différentes suivant la manière dont le reste du modèle est élaboré (perception, action, temps, interaction, etc.) ou encore IRM4S qui traite de l'utilisation des notions d'influence et de réaction pour la simulation de systèmes multi-agents [Michel2007, Chevrier2008].</p>

            <p>De plus, notre méthode, de par sa conception hybride, impose de séparer les calculs liés aux agents (CPU), des calculs liés à l’environnement (GPU) ce qui introduit un mécanisme en deux phases sur les parties du modèle concernées. Ce mécanisme peut être, à juste titre, relié à une approche de type IRM4S (comme souligné dans [Michel2015]). Ainsi, il pourrait être très intéressant dans un premier temps de voir dans quelle mesure il est possible d'intégrer le modèle IRM4S dans nos travaux.</p>

            <p>D'une manière générale, une de nos perspectives de recherche est donc de mener une réflexion autour de l'ordonnancement des agents et sur son impact sur la dynamique des systèmes dans un contexte d'utilisation hybride du GPGPU ou d'architectures matérielles massivement parallèles.</p>

            <div class="ajax-page-nav">
                <div class="nav-item ajax-page-prev-next">
                    <a class="ajax-page-load" href="./these/t_chap7.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                    <a class="ajax-page-load" href="./these/t_annexes.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
                </div>
                <div class="nav-item ajax-page-close-button">
                    <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
                </div>
            </div>

            <script type="text/javascript">
                    function customAjaxScroll() {
                        var windowWidth = $(window).width();
                        if (windowWidth > 991) {
                            // Custom Ajax Page Scroll
                            $("#ajax-page").mCustomScrollbar({
                                scrollInertia: 8,
                                documentTouchScroll: false
                            });
                        } else {
                            $("#ajax-page").mCustomScrollbar('destroy');
                        }
                    }

                    jQuery(document).ready(function($){

                        // Ajax Loaded Page Scroll
                        customAjaxScroll();


                        $('.portfolio-page-carousel').owlCarousel({
                            smartSpeed:1200,
                            items: 1,
                            loop: true,
                            dots: true,
                            nav: true,
                            navText: false,
                            margin: 10
                        });

                    });

                    jQuery(window).on('resize', function() {
                        customAjaxScroll();
                    });
                </script>
        </div>
    </div>
</div>

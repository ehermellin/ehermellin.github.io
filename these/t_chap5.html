<div id="ajax-page" class="ajax-page-content">
    <div class="ajax-page-wrapper">
        <div class="ajax-page-nav">
            <div class="nav-item ajax-page-prev-next">
                <a class="ajax-page-load" href="./these/t_chap4.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                <a class="ajax-page-load" href="./these/t_chap6.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
            </div>
            <div class="nav-item ajax-page-close-button">
                <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
            </div>
        </div>

        <div class="ajax-page-title">
            <div class="chapter-title"><h2>Chapitre 5 : Expérimentation du principe de délégation GPU</h2></div>
        </div>

        <div class="row">
            <br/>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap1.html"> Chapitre 1 : Simulation multi-agent</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap2.html"> Chapitre 2 : Calcul haute performance et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap3.html"> Chapitre 3 : Simulations multi-agents et GPGPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap4.html"> Chapitre 4 : Le principe de délégation GPU des perceptions agents</a></p></li>
                </ul>
            </div>
            <div class="col-sm-6 col-md-6 subpage-block">
                <ul class="project-general-info">
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap6.html"> Chapitre 6 : Définition d'une méthode de conception basée sur la délégation GPU</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap7.html"> Chapitre 7 : Conclusion</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_chap8.html"> Chapitre 8 : Perspectives de recherche</a></p></li>
                    <li><p><i class="fa fa-globe"></i> <a class="ajax-page-load" href="./these/t_bib.html"> Bibliographie</a></p></li>
                </ul>                
            </div>

            <p>Les résultats obtenus lors des premières expérimentations du principe de délégation GPU ont confirmé le potentiel de cette approche au regard des objectifs poursuivis. Cependant, les deux cas d'études précédemment présentés ne nous offraient pas un recul suffisant sur son utilisation et donc sur la meilleure façon de l'implémenter. Notamment, il nous était nécessaire de tester de manière plus poussée la nouvelle version du principe de délégation GPU [Hermellin-AAMAS-2016] proposée lors de l'expérimentation sur le modèle de <i>flocking</i>. Ceci afin de nous permettre d'évaluer, par la pratique, le champ d'application réel de l'approche ainsi que sa capacité à produire des éléments facilement réutilisables dans d'autres simulations et par là ses avantages et ses limites [Hermellin-CNSC-2016]. Nous présentons donc, dans ce chapitre, une expérimentation du principe de délégation GPU sur quatre nouveaux modèles multi-agents (<i>Game of Life</i>, <i>Segregation</i>, <i>Fire</i> et <i>DLA</i>) ainsi qu'un bilan autour de l'utilisation de ce principe.</p>

            <br/>
            <div class="block-title">
                <h3>Expérimentations</h3>
            </div>

            <p>Les modèles utilisés pour ces nouveaux tests n'ont pas été choisis au hasard. En 2008, Aaby et Perumalla ont été les premiers à proposer une étude sur l'intérêt d'utiliser le GPGPU dans le contexte des simulations multi-agents [Perumalla2008]. Pour ce faire, ils ont sélectionné plusieurs modèles multi-agents différents et les ont adaptés via une approche tout-sur-GPU. Cette variété dans le choix des modèles a permis de proposer un aperçu plus ou moins global de ce qu'il était possible de faire avec le GPGPU dans un contexte agent.</p>

            <p>La diversité étant une des caractéristiques clé du domaine agent (comme l'illustre le grand nombre de plates-formes de développement de simulations multi-agents, et les nombreuses approches permettant d'utiliser le GPGPU dans ces simulations), nous avons considéré que prendre également en compte des modèles très différents allait apporter une certaine crédibilité à l'approche proposée en plus de tester sa généricité. Nous avons donc choisi de reprendre deux des modèles utilisés dans l'étude de Perumalla et Aaby (<i>Game of Life</i> et <i>Segregation</i>) [Perumalla2008] et, pour introduire plus de variété, deux modèles parmi ceux disponibles dans la librairie de NetLogo (<i>Fire</i> et <i>DLA</i>).</p>

            <p>Pour chacun de ces quatre modèles, nous avons suivi le schéma suivant :</p>
            <ul>
            <li><p> Nous présentions le modèle et sa dynamique globale ;</p></li>
            <li><p> Nous identifiions les calculs les plus gourmands qui pourraient bénéficier du GPGPU ;</p></li>
            <li><p> Nous implémentions le principe de délégation GPU ;</p></li>
            <li><p> Nous réalisions des tests de performance.</p></li>
            </ul>

            <p>Tous les tests de performance menés ont suivi le même protocole expérimental qui a consisté à simuler consécutivement les versions CPU et hybride (CPU + GPU) de chaque modèle en faisant varier la taille de l'environnement ainsi que la densité des agents. Chaque simulation est alors exécutée plusieurs fois sur une période de 10 000 pas de temps pour permettre de calculer le temps moyen d'exécution d'une itération (le temps le plus faible étant le meilleur), nous donnant ainsi une valeur permettant de comparer les deux versions du modèle. Pour ces tests, nous avons réutilisé la même configuration que précédemment. Niveau logiciel, la version 3.0.0.4 de la plate-forme TurtleKit a été utilisée ainsi que CUDA en version 6.5 et JCUDA en version 0.6.5.</p>

            <h4>Le modèle <i>Game of Life</i></h4>

            <p><b>Présentation du modèle</b></p>

            <p>Le jeu de la vie défini par Conway [Gardner1970] n'est pas vraiment un jeu au sens ludique du terme. C'est à l'origine un automate cellulaire qui démontre que des motifs complexes peuvent émerger de la mise en application de règles simples. Le jeu se déroule sur une grille à deux dimensions dont les cases peuvent prendre deux états distincts : vivantes ou mortes. À chaque étape, l'évolution d'une cellule est entièrement déterminée par l'état de ses huit voisines à partir des règles pré-établies suivantes :</p>
            <ul>
            <li><p> Une cellule vivante possédant moins de deux ou plus de trois voisines vivantes meurt ;</p></li>
            <li><p> Une cellule vivante possédant deux ou trois voisines vivantes le reste ;</p></li>
            <li><p> Une cellule morte possédant exactement trois voisines vivantes devient vivante (elle naît).</p></li>
            </ul>
            <p>Ainsi, bien qu'il ne contienne pas d'agents, il définit une dynamique de l'environnement qui est représentative de celles rencontrées dans les systèmes multi-agents (ce qui justifie son intégration dans l'étude menée).</p>

            <p>Pour notre expérimentation, nous avons défini un modèle contenant seulement un environnement représenté sous la forme d'une grille carrée à deux dimensions torique et discrétisée dans laquelle les cellules sont initialisées de manière aléatoire. À chaque pas de simulation, les états des cellules sont mises à jour en fonction des règles précédemment définies.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/comportementsGameoflife.svg" alt=""/>
            </div>

            <p><b>Application du principe de délégation GPU</b></p>

            <p>Le calcul qui nécessite le plus de ressource dans ce modèle se situe à l'étape (1) et consiste en la réalisation d'un calcul itératif (une boucle séquentielle) sur toutes les cellules de l'environnement : il met à jour les états des cellules pour le prochain pas de simulation. Ainsi, plus l'environnement est grand et plus le temps nécessaire à la réalisation de ce calcul est important. Vu que ce modèle est un automate cellulaire, l'évolution de l'état des cellules (et leur mise à jour) est déjà une dynamique de l'environnement compatible avec le critère du principe de délégation GPU. Il est donc possible de traduire le calcul de cette dynamique en module GPU.</p>

            <p>Afin de créer un module GPU efficient, il est nécessaire de se focaliser sur les structures de données qui vont lui être envoyées. Plus précisément, pour éviter d'avoir des temps de transfert trop importants entre le CPU et le GPU, les données doivent être envoyées seulement une fois par pas de simulation. Ainsi, les états de chaque cellule (1 pour une cellule vivante, 0 pour une cellule morte) sont écrits dans un tableau à une dimension (<i>statesArray</i>, correspondant à la taille de l'environnement) en fonction de sa position. Ce tableau est ensuite envoyé au GPU qui réalise la somme des états des cellules (ce qui revient à faire la somme des cellules vivantes) présentes dans le voisinage de Moore de chaque cellule de l'environnement.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/calculPresenceGOL.svg" alt=""/>
            </div>

            <p>Le résultat de cette somme est ensuite sauvegardé dans un nouveau tableau à une dimension (<i>resultArray</i>). Ainsi, chaque cellule du tableau résultat contient une valeur comprise entre 0 (aucune cellule vivante dans mon voisinage) et 8 (toutes mes voisines sont vivantes). Ce tableau résultat est utilisé pour mettre à jour la grille et calculer le prochain pas de simulation en accord avec les règles de transitions du modèle.</p>

<pre>
i = blockIdx.x * blockDim.x + threadIdx.x ;
j = blockIdx.y * blockDim.y + threadIdx.y ;
sumOfState = 0 ;

Si(i &lt; width et j &lt; height){
    Pour(cellule dans mooreNeighborhood(statesArray[convert1D(i,j)])){
        sumOfState += getNeighborsValue(cellule);
    }
}

resultArray[convert1D(i,j)] = sumOfState ;
</pre>

           <p>La traduction du calcul du nombre de cellules voisines vivantes a mené à la création d'un nouveau module GPU : le module <i>Voisinage</i>. En effet, alors que ce module de calcul peut sembler très simpliste (il réalise une simple somme sur les cellules voisines), il peut être utilisé d'une manière plus générique en tant que fonction d'analyse de voisinage (type d'agents, nombre d'agents, etc.). De ce fait, il a été réutilisé dans les implémentations des modèles <i>Segregation</i> et <i>DLA</i>. Le seul pré-requis est de bien formater les données qui lui sont envoyées.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/kernelGOL.svg" alt=""/>
            </div>

            <p><b>Performance du modèle</b></p>

            <p>Pour tester les performances du modèle <i>Game of Life</i>, nous avons simulé successivement les versions CPU et hybride pour des environnements de taille 256, 512, 1 024 et 2 048. Pour chacune de ces tailles d'environnement, nous avons fixé la densité des agents à 50 %.</p>

            <div id="chart_chap5_gol" class="chart"></div>

            <p>Le graphique montre clairement que l'intégration du module <i>Voisinage</i> augmente les performances du modèle. Sans surprise, ce gain est d'autant plus important que l'environnement est grand : jusqu'à 5 fois plus rapide qu'une exécution séquentielle du modèle.</p>

            <h4>Le modèle <i>Segregation</i></h4>

            <p><b>Présentation du modèle</b></p>

            <p>Le modèle social <i>Segregation</i> développé par Schelling [Schelling1978] traite de la dynamique du partage de l'espace entre différents groupes. Dans le contexte d'un quartier où plusieurs types d'entités sont mélangés, il démontre à quelles conditions ce même quartier peut devenir ségrégé. Et cela même si ce n'est pas ce que souhaitaient ses habitants : si chacun admet, voire souhaite, un voisinage différent de lui (mais "pas trop" sinon il quitte le quartier) le résultat final dépendra de la proportion de départ et de ce dernier seuil. Schelling montre, qu'à raison de cette tolérance limitée, le quartier peut se retrouver dans deux situations stables possibles : une de ségrégation pure ou une où les entités restent mélangées.</p>

            <p>Pour notre expérimentation, nous avons défini un modèle dans lequel deux types d'agents sont distribués aléatoirement (dans les mêmes proportions) dans un environnement carré et discrétisé à deux dimensions : les agents rouges et les agents verts. Le but de ces agents est d'être heureux en restant à proximité d'agents de même couleur (chaque agent rouge veut vivre près d'au moins un certain nombre d'agents rouges, il en est de même pour les agents verts). Si ils ne sont pas satisfaits à leur position, les agents se déplacent aléatoirement vers un nouvel emplacement afin de trouver un meilleur endroit qui correspondra mieux à leur objectif de bonheur.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/comportementsSegregation.svg" alt=""/>
            </div>

            <p><b>Application du principe de délégation GPU</b></p>

            <p>Les calculs les plus gourmands dans ce modèle sont situés aux étapes (2) et (3) qui consistent à éditer, pour chaque agent, une liste des voisins les plus proches puis à parcourir cette liste afin de calculer leur bonheur (calculer en fonction du nombre et du type d'agents présents autour d'eux). Vu que ces deux étapes reposent sur la réalisation et le parcours de nombreuses boucles séquentielles (et cela à chaque pas de simulation), le temps de calcul requis va considérablement s'accroitre lorsque le nombre d'agents va augmenter. En accord avec les critères du principe de délégation GPU, le calcul du bonheur ne peut être transformé en dynamique environnementale car il modifie l'état de l'agent. Cependant, il est possible de transformer la perception préalable à ce calcul de bonheur qui consiste à établir le voisinage de chaque agent (le type et nombre d'agents).</p>

            <p>Le bonheur des agents est défini en testant la couleur des voisins et en additionnant le nombre d'agents de chaque communauté. Cela revient à compter le nombre d'agents de chaque communauté présent dans le voisinage pour chaque cellule de l'environnement. Il est donc possible de réutiliser le module <i>Voisinage</i> précédemment créé. Pour cela, il nous faut adapter la structure de données afin d'utiliser correctement ce module GPU. Ainsi, chaque agent va spécifier, à chaque pas de simulation, à quelle communauté il appartient en écrivant dans un tableau à une dimension (<i>communityArray</i>, qui correspond à la taille de l'environnement) un nombre propre à sa communauté : 1 pour la communauté verte et -1 pour la rouge. Ce tableau est ensuite envoyé au GPU qui réalise la somme de ces nombres (le voisinage de Moore est une nouvelle fois utilisé) pour tout l'environnement et écrit le résultat dans un nouveau tableau (<i>resultArray</i>). Chaque case du tableau résultat contient donc une variable pouvant prendre une valeur comprise entre -8 (tous les agents du voisinage sont rouges) et 8 (tous les agents sont verts). Les valeurs présentes dans ce tableau sont ensuite utilisées par les agents, en fonction de leur position, pour calculer leur bonheur.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/calculPresenceSeg.svg" alt=""/>
            </div>

            <p>Ainsi, dans le cadre de l'application du principe de délégation GPU sur le modèle <i>Segregation</i>, il a été possible de réutiliser le module <i>Voisinage</i>, initialement créé lors de l'implémentation du modèle <i>Game of Life</i>, en adaptant seulement les données envoyées à ce module.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/kernelSeg.svg" alt=""/>
            </div>

<pre>
Tantque(simu){
    /*Activation des agents*/
    Pour(agent dans listOfAgents){
        computeHapiness(communityArray[]);
        updateAgent();
        getNeighbors();
        fillCommunityArray(communityArray[]);
    }

    /*Activation de l'environnement*/
    executeGPUKernel( Voisinage(communityArray[]) );
}
</pre>

            <p><b>Performance du modèle</b></p>

            <p>Pour tester les performances du modèle <i>Segregation</i>, nous avons simulé successivement les versions CPU et hybride pour des environnements de taille 256, 512, 1 024 et 2 048. Pour chacune de ces tailles d'environnement, nous avons fixé la densité des agents à 90 %.</p>

            <div id="chart_chap5_seg" class="chart"></div>

            <p>Le graphique montre, comme pour le modèle <i>Game of Life</i>, que l'intégration du module <i>Voisinage</i> augmente les performances du modèle. Cependant, pour le modèle <i>Segregation</i>, le gain reste constant quelque soit la taille de l'environnement : environ 5 fois plus rapide que l'exécution séquentielle du modèle.</p>

            <h4>Le modèle <i>Fire</i></h4>

            <p><b>Présentation du modèle</b></p>

            <p>Le modèle <i>Fire</i> est inspiré d'une simulation présente dans la librairie de NetLogo qui simule la propagation d'un incendie dans une forêt. Il montre que les chances pour que l'incendie affecte le plus grand nombre d'arbres possibles dépend essentiellement de la densité des arbres dans l'environnement.</p>

            <p>Pour notre expérimentation, nous avons défini un modèle dans lequel tous les arbres sont considérés comme des agents placés aléatoirement dans un environnement à deux dimensions carré et discrétisé. Ces arbres peuvent être dans trois états différents : (1) vivant, (2) en feu et (3) mort. Lorsqu'il est en feu, un arbre dégage de la chaleur qui se diffuse dans l'environnement. Cette chaleur, quand elle atteint un certain seuil, peut enflammer d'autres arbres aux alentours. Ce seuil est défini aléatoire pour chaque agent (dans une plage de valeurs). Un arbre voit sa vie (un paramètre propre à chaque arbre) décroitre lorsqu'il brûle. Il meurt lorsque sa vie atteint 0.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/comportementsFire.svg" alt=""/>
            </div>

            <p><b>Application du principe de délégation GPU</b></p>
            
            <p>Le calcul séquentiel nécessitant le plus de ressources est présent dans l'étape (1) et consiste à calculer la diffusion de la chaleur émise par les arbres dans l'environnement. Pour réaliser cette diffusion, il est nécessaire d'effectuer une boucle séquentielle sur toutes les cases de l'environnement. Ainsi, plus l'environnement est grand et plus le temps de calcul de la diffusion est important. Ce calcul étant déjà une dynamique de l'environnement, il est compatible avec le critère du principe de délégation GPU et peut être traduit en module GPU.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/calculDiffusionFire.svg" alt=""/>
            </div>

            <p>Dans le cas d'étude sur le modèle MLE, un module GPU dédié au calcul de la diffusion a été créé. Il est possible de le réutiliser pour le modèle <i>Fire</i> en adaptant uniquement les structures de données qui vont lui être envoyées. Chaque agent va ainsi déposer une certaine quantité de chaleur (cette valeur dépend de l'état de l'agent) en fonction de sa position dans un tableau à une dimension (<i>agentHeatArray</i>, qui correspond à la taille de l'environnement). Un deuxième tableau (<i>envHeatArray</i>) contenant les valeurs de chaleur déjà présentes dans l'environnement est également utilisé. Ces deux tableaux sont ensuite envoyés au GPU qui calcule la diffusion sur tout l'environnement. Plus précisément, le <i>kernel</i> GPU réalise la somme de la chaleur dans le voisinage de Moore de chaque cellule, puis ajoute la chaleur déjà présente à cette position et module enfin le résultat global par une variable de diffusion avant d'écrire dans un tableau (<i>resultArray</i>) le résultat. Une fois le calcul réalisé, les agents n'ont plus qu'à percevoir dans l'environnement la valeur de chaleur correspondant à leur position et agir en conséquence.</p>

<pre>
i = blockIdx.x * blockDim.x + threadIdx.x ;
j = blockIdx.y * blockDim.y + threadIdx.y ;
sumOfHeat = 0 ;

Si(i &lt; width et j &lt; height){
    Pour(cellule dans voisinage(agentHeatArray[convert1D(i,j)], radius)){
        sumOfHeat = envHeatArray[convert1D(i,j)] + getNeighborsValue(cellule);
    }
}

resultArray[convert1D(i,j)] = sumOfHeat * heatAdjustment;
</pre>

            <p>Bien que le module GPU <i>Diffusion</i> ait été réutilisé ici, il a fallu le modifier légèrement afin de le rendre plus générique. Ayant été créé spécialement pour la diffusion de phéromones, il ne pouvait en l'état accepter d'autres types de données. Nous l'avons donc généralisé en ce sens. De plus, il est désormais capable de prendre en compte des données venant des agents et des données déjà présentes dans l'environnement, cela afin d'augmenter le champ d'application de ce module.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/kernelFire.svg" alt=""/>
            </div>

<pre>
Tantque(simu){
    /*Activation des agents*/
    Pour(agent dans listOfAgents){
        updateAgent();
        live();
        fillHeatArray(agentHeatArray[]);
    }

    /*Activation de l'environnement*/
    updateEnvironment();
    executeGPUKernel( Diffusion(agentHeatArray[],envHeatArray[]) );
}
</pre>

            <p><b>Performance du modèle</b></p>

            <p>Pour tester les performances du modèle <i>Fire</i>, nous avons simulé successivement les versions CPU et hybride pour des environnements de taille 256, 512, 1 024 et 2 048. Pour chacune de ces tailles d'environnement, nous avons fait varier la densité des agents entre 10 % et 100 %.</p>

            <div id="chart_chap5_fire" class="chart"></div>

            <p>Les graphiques montrent que, contrairement aux deux précédents modèles, les gains de performance sont moins significatifs. En effet, l'accélération n'est au maximum que de x 2 pour des environnements de grande taille (1 024 et 2 048) et stagne autour de x1.5 pour des environnements plus petits. La densité des agents n'a pas non plus un réel impact sur les résultats de ces tests.</p>

            <h4>Le modèle <i>DLA</i></h4>

            <p><b>Présentation du modèle</b></p>

            <p>Le modèle <i>DLA</i> est également tiré de la librairie NetLogo. Il permet de simuler des phénomènes d'agrégation dans lesquels des particules se déplaçant aléatoirement se rassemblent pour former des structures fractales ressemblant à ce que l'on peut trouver dans la nature : cristaux, champignons, foudre, etc.</p>

            <p>Pour notre expérimentation, nous avons défini un modèle dans lequel chaque particule est considérée comme un agent qui se déplace aléatoirement dans un environnement à deux dimensions carré et discrétisé. De manière aléatoire, un des agents en mouvement (coloré en rouge) devient statique et change de couleur (il devient vert). Par la suite, lorsqu'un agent rouge rencontre un agent vert, il s'arrête et change également de couleur. Les autres continuent de se déplacer.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/comportementsDLA.svg" alt=""/>
            </div>

            <p><b>Application du principe de délégation GPU</b></p>

            <p>Les calculs qui requièrent le plus de puissance sont localisés dans les étapes (2) et (3) et consistent en l'établissement d'une liste de voisins présents dans un certain rayon et au parcours de cette liste pour identifier le plus proche. Le temps de calcul nécessaire est donc fortement dépendant du nombre d'agents. Vu que l'action de vérifier si un agent vert se trouve dans le voisinage proche ne modifie pas les états des agents, il est possible de la transformer en une dynamique environnementale réalisée pour tout l'environnement à chaque pas de simulation et calculée par un module GPU.</p>

            <p>Cette recherche de voisins a déjà été réalisée pour le modèle <i>Game of Life</i>, nous allons donc réutiliser une nouvelle fois le module créé et seulement adapter les données envoyées. Ainsi, chaque agent va déposer une marque de présence en fonction de sa position et du rôle joué dans un tableau à une dimension (<i>presenceArray</i>, correspondant à la taille de l'environnement) : 1 pour indiquer sa présence si l'agent est vert et 0 dans les autres cas. Ce tableau est ensuite envoyé au GPU qui réalise la somme des états des cellules présentes dans le voisinage de Moore pour chaque cellule de l'environnement et écrit le résultat dans un nouveau tableau (<i>resultArray</i>). Chaque cellule du tableau contient donc une valeur étant soit égale à 0 (aucun voisin dans le voisinage), soit supérieur à 0 (il y a des voisins dans mon proche voisinage). Une fois ce calcul réalisé, les agents n'ont plus qu'à percevoir dans l'environnement la valeur de présence correspondant à leur position et agir en conséquence.</p>

            <p>Tout comme pour le modèle <i>Segregation</i>, le module GPU <i>Voisinage</i> a été réutilisé tel quel sans modification.</p>

            <div class="portfolio-page-image">
                <img src="./these/images_chap5/kernelDLA.svg" alt=""/>
            </div>

<pre>
Tantque(simu){
    /*Activation des agents*/
    Pour(agent dans listOfAgents){
        updateAgent();
        live();
        fillPresenceArray(presenceArray[]);
    }

    /*Activation de l'environnement*/
    executeGPUKernel( Voisinage(presenceArray[]) );
}
</pre>

            <p><b>Performance du modèle</b></p>

            <p>Pour tester les performances du modèle <i>DLA</i>, nous avons simulé successivement les versions CPU et hybride pour des environnements de taille 256, 512, 1 024 et 2 048. Pour chacune de ces tailles d'environnement, nous avons fait varier la densité des agents entre 10 % et 90 %.</p>

            <div id="chart_chap5_dla" class="chart"></div>

            <p>Les graphiques montrent que l'intégration du module <i>Voisinage</i> augmente les performances du modèle. De plus, ce gain s'accentue d'autant plus que la densité des agents dans l'environnement est importante (jusqu'à 14 fois plus rapide qu'une exécution séquentielle du modèle). Cependant, les performances diminuent lorsqu'on augmente la taille de l'environnement ce qui va à l'encontre de tout ce que l'on a pu observer jusqu'ici.</p>

            <br/>
            <div class="block-title">
                <h3>Résultats de l'expérimentation du principe de délégation GPU</h3>
            </div>

            <h4>Du point de vue des performances</h4>

            <p>A partir des différents résultats de performance établis pour chacun des quatre modèles précédents, on observe que les gains de performance, obtenus grâce à l'application du principe de délégation GPU, varient principalement à cause de deux facteurs :</p>
            <ul>
            <li><p> la taille de l'environnement : le gain est d'autant plus grand que l'environnement est large;</p></li>
            <li><p> la densité des agents : le gain augmente d'autant plus que la densité est importante.</p></li>
            </ul>
            <p>Cependant, des exceptions ont été observées. Concernant le modèle <i>Fire</i>, le gain de performance entre les deux versions du modèle est très limité et reflète probablement une mauvaise utilisation (ou optimisation) du module GPU. Pour le modèle <i>DLA</i>, le gain de performance a évolué à l'encontre de ce qui a pu être observé avec les autres modèles en diminuant d'autant plus que l'environnement grandissait. Du fait que seule une partie du modèle bénéficie du GPGPU, nous expliquons cette baisse de performance par une hausse de la consommation des ressources par les agents ce qui a pu ralentir la simulation.</p>

            <p>D'une manière générale, on note que chaque application du principe de délégation GPU est unique en termes de performance. En effet, les gains obtenus varient significativement en fonction du modèle considéré : ils peuvent atteindre x14 mais se situent la plupart du temps autour de x2 et x5 ce qui est un gain non négligeable. Cependant, une limite à cette approche est le fait de ne pouvoir prédire à l'avance quels vont être les gains de performance. L'utilisateur peut juger inintéressant d'investir du temps dans la modification de son modèle si cela ne lui apporte pas l'accélération escomptée. L'idée est donc de proposer une solution à ce problème.</p>

            <p>Enfin, si nous comparons les résultats obtenus (en termes de performance) entre le principe de délégation GPU et l'étude menée dans [Perumalla2008], il apparaît clairement que les implémentations réalisées dans cette dernière sont bien plus efficientes. En effet, elles autorisent des gains de performance bien plus élevés (qui peuvent atteindre jusqu'à x40) car ces dernières reposent sur une approche tout-sur-GPU. Cette différence par rapport à ce que nous proposons doit cependant être mise en perspective. Comme indiqué dans l'étude, l'objectif de ces implémentations était la recherche de performance pure et elle n'a pu se faire qu'en impactant directement certains aspects conceptuels pourtant identifiés comme essentiels. L'approche de délégation GPU est certes moins performante mais permet de considérer des perspectives liées au génie logiciel telles que l'accessibilité, la réutilisabilité ou la généricité. Cela a déjà été souligné par les expériences précédentes et est une nouvelle fois vérifié ici.</p>

            <div id="chart_chap5_recap" class="chart"></div>

            <h4>D'un point de vue conceptuel</h4>
            
            <p>L'étude menée par Perumalla et Aaby [Perumalla2008] concluait qu'utiliser le GPGPU dans les simulations multi-agent ne pouvait se faire qu'au détriment de la généricité, de l'accessibilité et surtout de la réutilisabilité.</p>
            <blockquote>
            "Execution is two to three orders of magnitude faster with a GPU [...] but at the cost of decrease in modularity, ease of programmability and reusability. [...] Effective use of data parallel execution, in general, seems to require resolution of modeling and execution challenges."
            </blockquote>

            <p>Le principe de délégation GPU montre que, même si les performances offertes sont moins impressionnantes (voir section précédente), son application remet en cause les conclusions énoncées dans [Perumalla2008]. En effet, la conception hybride, sur laquelle repose le principe de délégation GPU, lui permet d'être plus générique en lui offrant un champ d'application plus large (prise en compte d'une plus grande variété de modèles). De plus, les modules GPU produits grâce à cette approche sont génériques, indépendants et plus facilement réutilisables. Nous en avons fait l'expérience dans l'expérimentation menée dans ce chapitre avec la réutilisation de deux modules créés pour des modèles complètements différents : réutilisation du module <i>Diffusion</i> créé pour le modèle MLE dans le modèle <i>Fire</i>, réutilisation du module <i>Voisinage</i> créé pour le modèle <i>Game of Life</i> dans le modèle DLA. Ce point est important et représente une différence majeure avec les travaux conduits dans [Perumalla2008].</p>

            <p>Si l'on considère l'accessibilité du GPGPU, la délégation GPU permet de considérablement l'améliorer. En effet, grâce à son aspect modulaire, elle permet de produire des <i>kernels</i> très simples ne nécessitant que très peu de connaissances dans cette technologie. De plus, en ne transformant seulement qu'une partie spécifique des calculs de l'agent, il est possible de tirer parti de la puissance de calcul du GPU sans changer le modèle de l'agent.</p>

            <p>Finalement, en permettant de choisir ce qui va être exécuté sur le GPU et sur le CPU, la stratégie proposée par le principe de délégation GPU permet de surmonter les difficultés rencontrées lors de l'implémentation des comportements des agents sur GPU, notamment dans une approche tout-sur-GPU. Cela a également comme conséquence de faciliter l'utilisation du GPGPU dans le contexte des simulations multi-agents.</p>

            <br/>
            <div class="block-title">
                <h3>Vers une généralisation de l'approche</h3>
            </div>

            <p>Dans un premier temps, nous avons décidé, dans ce chapitre, d'appliquer le principe de délégation GPU sur quatre nouveaux modèles multi-agents que nous avons voulu très différents : <i>Game of Life</i>, <i>Segregation</i>, <i>Fire</i> et <i>DLA</i>. Ceci pour juger d'une part du champ d'application de l'approche et d'autre part de ses avantages et limites. </p>

            <p>Cette expérimentation a souligné une nouvelle fois des bonnes performances de l'approche ainsi que de sa capacité à prendre en compte les trois critères que nous avons considérés comme essentiels dés le début de ce manuscrit (généricité, accessibilité, réutilisabilité). On peut également noter que le principe n'a pas eu besoin d'être à nouveau modifié pour pouvoir être appliqué sur ces nouveaux modèles.</p>

            <p>Ainsi, nous avons considéré comme étape finale à ce travail, de formaliser la méthode implicitement utilisée tout au long de ces différentes expérimentations. En effet, nous avons remarqué de nombreuses redondances dans l'application du principe de délégation GPU. Nous avons notamment suivi à chaque fois le même processus itératif d'application consistant à (1) identifier les calculs les plus gourmands, (2) adapter les structures de données des calculs considérés et enfin (3) implémenter la délégation GPU (créer les modules GPU et les intégrer aux modèles).</p>

            <p>La généralisation de l'approche sous la forme d'une méthode de conception est proposée au chapitre suivant. Nous pensons qu'une telle méthode devrait faciliter l'utilisation de notre approche et promouvoir l'utilisation du GPGPU dans les simulations multi-agents.</p>

            <div class="ajax-page-nav">
                <div class="nav-item ajax-page-prev-next">
                    <a class="ajax-page-load" href="./these/t_chap4.html"><i class="pe-7s-icon pe-7s-angle-left"></i></a>
                    <a class="ajax-page-load" href="./these/t_chap6.html"><i class="pe-7s-icon pe-7s-angle-right"></i></a>
                </div>
                <div class="nav-item ajax-page-close-button">
                    <a id="ajax-page-close-button" href="#"><i class="pe-7s-icon pe-7s-close"></i></a>
                </div>
            </div>   

            <script type="text/javascript">
                function customAjaxScroll() {
                        var windowWidth = $(window).width();
                        if (windowWidth > 991) {
                            // Custom Ajax Page Scroll
                            $("#ajax-page").mCustomScrollbar({
                                scrollInertia: 8,
                                documentTouchScroll: false
                            });
                        } else {
                            $("#ajax-page").mCustomScrollbar('destroy');
                        }
                    }

                    jQuery(document).ready(function($){

                        // Ajax Loaded Page Scroll
                        customAjaxScroll();

                        Highcharts.chart('chart_chap5_gol', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Modèle Game of Life, résultats de performance'
                            },
                            xAxis: {
                                title: {
                                    text: 'Taille environnement'
                                },
                                categories: ['0','256', '512', '1024', '2048']
                            },
                            yAxis: {
                                title: {
                                    text: 'Temps de calcul par itération [ms]'
                                }
                            },
                            series: [{
                                name: 'CPU',
                                data: [2, 12, 47, 347]
                            },{
                                name: 'Hybride',
                                data: [1, 4, 21, 68]
                            }]
                        });

                        Highcharts.chart('chart_chap5_seg', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Modèle Segregation, résultats de performance'
                            },
                            xAxis: {
                                title: {
                                    text: 'Taille environnement'
                                },
                                categories: ['0','256', '512', '1024', '2048']
                            },
                            yAxis: {
                                title: {
                                    text: 'Temps de calcul par itération [ms]'
                                }
                            },
                            series: [{
                                name: 'CPU',
                                data: [210, 950, 3692, 10409]
                            },{
                                name: 'Hybride',
                                data: [43, 204, 796, 2307]
                            }]
                        });

                        Highcharts.chart('chart_chap5_fire', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Modèle Fire, résultats de performance'
                            },
                            xAxis: {
                                title: {
                                    text: 'Densité des agents'
                                },
                                categories: ['0', '10', '20', '30', '40', '50', '60', '70', '80', '90', '100']
                            },
                            yAxis: {
                                title: {
                                    text: 'Temps de calcul par itération [ms]'
                                }
                            },
                            series: [{
                                name: 'CPU 256',
                                data: [7, 10, 18, 14, 23, 22, 28, 47, 52, 60]
                            },{
                                name: 'CPU 512',
                                data: [31, 63, 46, 56, 79, 91, 100, 127, 137, 202]
                            },{
                                name: 'CPU 1024',
                                data: [117, 187, 380, 182, 243, 380, 492, 773, 967, 1094]
                            },{
                                name: 'Hybride 256',
                                data: [6, 14, 20, 16, 16, 21, 26, 32, 37, 46]
                            },{
                                name: 'Hybride 512',
                                data: [25, 39, 28, 41, 56, 79, 96, 113, 125, 149]
                            },{
                                name: 'Hybride 1024',
                                data: [100, 181, 212, 181, 234, 410, 483, 591, 682, 834]
                            }]
                        });

                        Highcharts.chart('chart_chap5_dla', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Modèle DLA, résultats de performance'
                            },
                            xAxis: {
                                title: {
                                    text: 'Densité des agents'
                                },
                                categories: ['22', '45', '68', '91']
                            },
                            yAxis: {
                                title: {
                                    text: 'Temps de calcul par itération [ms]'
                                }
                            },
                            series: [{
                                name: 'CPU 256',
                                data: [24, 86, 194, 351]
                            },{
                                name: 'CPU 512',
                                data: [112, 307, 744, 1699]
                            },{
                                name: 'CPU 1024',
                                data: [348, 712, 2217, 5926]
                            },{
                                name: 'Hybride 256',
                                data: [4, 9, 14, 26]
                            },{
                                name: 'Hybride 512',
                                data: [39, 67, 80, 133]
                            },{
                                name: 'Hybride 1024',
                                data: [124, 202, 371, 552]
                            }]
                        });

                        Highcharts.chart('chart_chap5_recap', {
                            chart: {
                                type: 'line'
                            },
                            title: {
                                text: 'Gains de performance obtenus lors des différentes expérimentations'
                            },
                            xAxis: {
                                title: {
                                    text: 'Taille environnement'
                                },
                                categories: ['256', '512', '1024', '2048']
                            },
                            yAxis: {
                                title: {
                                    text: 'Gains de performance'
                                }
                            },
                            series: [{
                                name: 'Game of Life',
                                data: [2.0, 2.2, 2.23, 5.10]
                            },{
                                name: 'Segregation',
                                data: [4.8, 4.7, 4.65, 4.6]
                            },{
                                name: 'Fire',
                                data: [1.4, 1.64, 1.79, 2.09]
                            },{
                                name: 'DLA',
                                data: [13.5, 12.7, 10.7, 10.0]
                            }]
                        });

                        $('.portfolio-page-carousel').owlCarousel({
                            smartSpeed:1200,
                            items: 1,
                            loop: true,
                            dots: true,
                            nav: true,
                            navText: false,
                            margin: 10
                        });

                    });

                    jQuery(window).on('resize', function() {
                        customAjaxScroll();
                    });

            </script>
        </div>
    </div>
</div>
